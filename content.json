{"meta":{"title":"Hexo","subtitle":"","description":"","author":"织梦行云","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-12-11T02:37:54.842Z","updated":"2020-12-11T02:37:54.842Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2020-12-11T02:40:05.917Z","updated":"2020-12-11T02:40:05.917Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2020-12-11T02:38:37.475Z","updated":"2020-12-11T02:38:37.475Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-12-11T02:39:01.888Z","updated":"2020-12-11T02:39:01.888Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-11T02:41:50.086Z","updated":"2020-12-11T02:41:50.086Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-12-11T02:39:36.154Z","updated":"2020-12-11T02:39:36.154Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux CentOS升级安装git","slug":"Linux CentOS升级安装git ","date":"2020-12-14T08:56:48.000Z","updated":"2020-12-15T07:25:07.630Z","comments":true,"path":"2020/12/14/Linux CentOS升级安装git /","link":"","permalink":"http://example.com/2020/12/14/Linux%20CentOS%E5%8D%87%E7%BA%A7%E5%AE%89%E8%A3%85git%20/","excerpt":"","text":"前言CentOS默认的yum安装git版本是1.8，但我们想升级它，需要自己去编译安装 环境 首先安装依赖123yum install gccyum install curl-devel expat-devel gettext-devel openssl-devel zlib-develyum install gcc perl-ExtUtils-MakeMaker 下载安装 前往镜像网站手动去下载git，或者我们可以用wget下载目前最新的2.9.5 1wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz 解压 1tar -zxf git-2.9.5.tar.gz 进入目录 1cd git-2.9.5 配置检测，并且设置安装目录 1./configure --prefix=/usr/local/git 编译安装 1make &amp;&amp; make install 配置环境变量我们需要配置环境变量才能全局使用git命令 在profile里配置环境变量1echo &#x27;export PATH=$PATH:/usr/local/git/bin&#x27; &gt; /etc/profile.d/git.sh 刷新环境变量，使其生效1source /etc/profile OK12[root@VM-0-11-centos git-2.9.5]# git --versiongit version 2.9.5","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"服务器/Linux","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[]},{"title":"Hexo部署GitHub Pages","slug":"Hexo部署GitHub-Pages","date":"2020-12-11T08:56:48.000Z","updated":"2020-12-15T02:28:33.505Z","comments":true,"path":"2020/12/11/Hexo部署GitHub-Pages/","link":"","permalink":"http://example.com/2020/12/11/Hexo%E9%83%A8%E7%BD%B2GitHub-Pages/","excerpt":"","text":"环境要求 node.js &gt; 10.13 git Hexo 默认你知道Hexo的使用方法 创建一个仓库(repository) 进入GitHub，右上角点击 New repository 将Repository name设置成 你的用户名.github.io ，注意，用户名必须跟你的一模一样 复制GitHub连接 git@github.com:Chenilove/Chenilove.github.io.git ，注意这里用HTTPS的话每次提交都要登录，推荐SSH 在Hexo项目根目录下，编辑_config.yml文件，里面修改 1234567# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: - type: git # 提交类型git repo: git@github.com:Chenilove/Chenilove.github.io.git # 提交仓库地址 branch: main # 分支GitHub的默认分支是main Gitee的分支是master 可以填branch让hexo默认提交 message: message # 提交信息 执行项目生成和部署命令 12hexo ghexo d 最后访问 https://chenilove.github.io/ 就可以了 issues 执行hexo d每次都要登录是怎么回事? 将_config.yml里的repo改成SSH（&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;）的链接就行了","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Hexo/"}],"tags":[]},{"title":"Linux关闭watchdog","slug":"Linux关闭watchdog","date":"2020-12-04T08:56:48.000Z","updated":"2020-12-15T03:10:06.174Z","comments":true,"path":"2020/12/04/Linux关闭watchdog/","link":"","permalink":"http://example.com/2020/12/04/Linux%E5%85%B3%E9%97%ADwatchdog/","excerpt":"","text":"sysctl命令控制1234567# 使用该命令直接关闭，值改为1时开启sysctl kernel.nmi_watchdog=0# 在/etc/sysctl.conf中增加如下内容，开机自动关闭kernel.nmi_watchdog = 0","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"服务器/Linux","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/"}],"tags":[]},{"title":"MySQL SELECT list is not in...MySQL关闭严格模式","slug":"MySQL SELECT list is not in...MySQL关闭严格模式","date":"2020-12-04T08:56:48.000Z","updated":"2020-12-15T03:18:50.282Z","comments":true,"path":"2020/12/04/MySQL SELECT list is not in...MySQL关闭严格模式/","link":"","permalink":"http://example.com/2020/12/04/MySQL%20SELECT%20list%20is%20not%20in...MySQL%E5%85%B3%E9%97%AD%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"SELECT list is not inGROUP BY clause and contains nonaggregated columnMySQL严格模式主要用以下场景 不支持对not null字段插入null值 不支持对自增长字段插入”值 不支持text字段有默认值 我们用不到时可以关闭它，在Laravel中可以编辑database.php，关闭严格模式，不使用框架时，可以编辑my.ini在[mysqld]加一行 12[mysqld]sql-mode=&quot;&quot; 重启MySQL，就关闭了","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[]},{"title":"linux与windows下 安装 ImageMagick 及其 php imagick扩展","slug":"linux与windows下 安装 ImageMagick 及其 php imagick扩展","date":"2020-11-04T08:56:48.000Z","updated":"2020-12-15T03:20:13.733Z","comments":true,"path":"2020/11/04/linux与windows下 安装 ImageMagick 及其 php imagick扩展/","link":"","permalink":"http://example.com/2020/11/04/linux%E4%B8%8Ewindows%E4%B8%8B%20%E5%AE%89%E8%A3%85%20ImageMagick%20%E5%8F%8A%E5%85%B6%20php%20imagick%E6%89%A9%E5%B1%95/","excerpt":"","text":"首先要安装两个东西，一个是ImageMagick，另一个是PHP扩展imagick Linux安装先安装ImageMagick 下载ImageMagick安装包1wget http://www.imagemagick.org/download/ImageMagick.tar.gz 解压1tar -xvfz ImageMagick.tar.gz 进入目录1cd ImageMagick-7.0.10-28 设置安装路径.后面安装php扩展需要用到;/usr/local/imagemagick1./configure --prefix=/usr/local/imagemagick 编译1make &amp;&amp; make install PHP imagick扩展安装（第二步）官网地址：http://pecl.php.net/package/imagick 下载imagick-3.4.41wget https://pecl.php.net/get/imagick-3.4.4.tgz 解压安装包1tar -zxvf imagick-3.4.4.tgz 进入安装文件1cd imagick-3.4.4.tgz/ 执行phpize命令1/usr/local/php/bin/phpize ImageMagick 6.8以上版本目录为/usr/local/include/ImageMagick-X,在configure之前先做下软连接1ln -s /usr/local/imagemagick/include/ImageMagick-7 /usr/local/imagemagick/include/ImageMagick 执行configure配置1./configure --with-php-config=/usr/local/php/bin/php-config --with-imagick=/usr/local/imagemagick 编译1make &amp;&amp; make install php.ini加入imagick.so1extensions=imagick.so Windows下安装原文链接 要下载扩展，需要清楚自己的PHP版本。通过phpinfo（）查看.红框的信息之后会用到 下载imagemagick程序地址:http://windows.php.net/downloads/pecl/deps/下载这个区域里面的对应版本.选择最高版本，我需要下载vc15的64位的安装imagemagick程序 把这个压缩包下载下来之后放到任意盘符。注意路径不要有中文和特殊字符。我是phpstudy集成环境，放在了D:\\phpstudy_pro\\imagemagick。这个是可以任意放置的。 然后配置环境变量。参照下图导入DLL文件在下载的文件里面，进入到bin目录。然后搜索.dll把所有的文件复制到PHP的根目录下搜索—全选–复制搞定下载Imagick扩展这里给出两个下载地址.如果不能用请再寻找下载地址一: http://windows.php.net/downloads/pecl/releases/imagick/下载地址二: https://pecl.php.net/package/imagick 解压之后在最下面找到php_imagick.dll文件，复制到PHP根目录下的ext目录下 其他.DLL文件 将解压后的imagick目录下的其他.dll后缀的文件全部复制粘贴到php根目录下 php.ini 文件并打开编辑,加入extension=php_imagick.dll这一行重启服务","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"环境","slug":"后端/PHP/环境","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"ThinkPHP里无法输出图片 设置响应头","slug":"ThinkPHP里无法输出图片 设置响应头","date":"2020-11-04T08:56:48.000Z","updated":"2020-12-15T03:23:19.444Z","comments":true,"path":"2020/11/04/ThinkPHP里无法输出图片 设置响应头/","link":"","permalink":"http://example.com/2020/11/04/ThinkPHP%E9%87%8C%E6%97%A0%E6%B3%95%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87%20%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%A4%B4/","excerpt":"","text":"今天写了一个PHP生成图片，想用浏览器查看，但是每次打开都是一串乱码，看样子是图片源二进制数据，然后查看了下响应头是text/html，那我明明设置了image/jpeg 1header(&quot;Content-type&quot;, &quot;image/jpeg&quot;); 这说明TP默认设置了text/html，查了官方文档，啥也没说，去网上查，才知道TP有个Response类，默认所有控制器输出text/html，官方文档啥也没说，只好自己去翻Response这个类了 1ThinkPHP6\\vendor\\topthink\\framework\\src\\think\\Response.php 基类Response被这几个类继承，我试了下File类，但是这个File是输出文件，浏览器直接下载了 1234$file = new File(&#x27;123.jpg&#x27;);$response = $file-&gt;mimeType(&#x27;image/jpeg&#x27;);throw new HttpResponseException($response); 在看看基类Response 1234567891011121314/** * 创建Response对象 * @access public * @param mixed $data 输出数据 * @param string $type 输出类型 * @param int $code 状态码 * @return Response */ public static function create($data = &#x27;&#x27;, string $type = &#x27;html&#x27;, int $code = 200): Response &#123; $class = false !== strpos($type, &#x27;\\\\&#x27;) ? $type : &#x27;\\\\think\\\\response\\\\&#x27; . ucfirst(strtolower($type)); return Container::getInstance()-&gt;invokeClass($class, [$data, $code]); &#125; 这里是自动找response目录下的响应类，但我只想设置一个响应头来显示我的图片，文档翻遍了没找到方法，然后看了看目录下的Html类，那我们可以自己写一个自定义类来输出自己想要的响应格式 1234567891011121314151617/** * Html Response */class Html extends Response&#123; /** * 输出type * @var string */ protected $contentType = &#x27;text/html&#x27;; public function __construct(Cookie $cookie, $data = &#x27;&#x27;, int $code = 200) &#123; $this-&gt;init($data, $code); $this-&gt;cookie = $cookie; &#125;&#125; 于是我在response目录写了一个Jpeg类 1234567891011121314151617/** * Html Response */class Jpeg extends Response&#123; /** * 输出type * @var string */ protected $contentType = &#x27;image/jpeg&#x27;; public function __construct(Cookie $cookie, $data = &#x27;&#x27;, int $code = 200) &#123; $this-&gt;init($data, $code); $this-&gt;cookie = $cookie; &#125;&#125; 可以输出图片了 123$response = Response::create(&#x27;&#x27;, &#x27;Jpeg&#x27;);$image-&gt;blob(&#x27;JPEG&#x27;);throw new HttpResponseException($response); 也许有办法不用这么麻烦，但是TP官方文档啥也没有写，一下子也找不到其他方法，导致我的header()函数都没用了，这里引用ThinkPHP论坛网友的一句话 框架的定义就是在于更快速、便捷地开发应用如果我使用了某款框架还是需要自己去注意条条款款，然后定义或修正许多形式上的规范，那还用框架干嘛呢本末倒置，鸡蛋里面挑骨头","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"ThinkPHP","slug":"后端/PHP/ThinkPHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/ThinkPHP/"}],"tags":[]},{"title":"配置 frp 实现内网穿透（Linux）","slug":"配置 frp 实现内网穿透（Linux）","date":"2020-05-04T08:56:48.000Z","updated":"2020-12-15T03:44:44.711Z","comments":true,"path":"2020/05/04/配置 frp 实现内网穿透（Linux）/","link":"","permalink":"http://example.com/2020/05/04/%E9%85%8D%E7%BD%AE%20frp%20%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%88Linux%EF%BC%89/","excerpt":"","text":"配置 frp 实现内网穿透frp 中文文档：https://github.com/fatedier/frp/blob/master/README_zh.md 一、frp 的作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 二、安装 frp 1. github 地址：https://github.com/fatedier/frp/releases 可以用 wget 下载，公网、内网服务器都下载一份。 123wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz 2、解压 tar -zxvf frp_0.33.0_linux_amd64.tar.gz 3、进入解压目录 cd frp_0.33.0_linux_amd64，这里所有 frpc 开头的文件都是客户端文件，所以全部删了，我们服务器只需要 frps 开头的文件 123rm -rf ./frpc* 4、配置服务端（公网服务器） 123vim ./frps.ini 注意配置文件不支持注释，请不要把汉字复制进去 1234567[common]bind_port = 7000 #与客户端绑定的进行通信的端口vhost_http_port = 6081 #访问客户端web服务自定义的端口号 保存然后启动服务./frps -c ./frps.ini，这是前台启动，后台启动命令为 nohup ./frps -c ./frps.ini &amp; 5、配置客户端（内网服务器），首先删掉 frps 开头文件文件,然后再进行配置，vim ./frpc.ini 123456789101112131415[common]server_addr = 47.93.33.108 #公网服务器ipserver_port = 7000 #与服务端bind_port一致[web]type = http #访问协议local_port = 80 #内网web服务的端口号custom_domains = www.mczhangyi.top #所绑定的公网服务器域名，一级、二级域名都可以 保存然后执行 Linux 的 Base 命令 123.&#x2F;frpc -c .&#x2F;frpc.ini windows 的 PowerShell 命令是 123.&#x2F;frpc.exe -c .&#x2F;frpc.ini 6、访问方式 （1）外网 ssh 访问内网服务器（直接使用配置里面数据演示） 47.93.33.108 port:6000 47.93.33.108 port:22 www.mczhangyi.top port:6000 www.mczhangyi.top port:22 （2）自定义绑定域名访问内网 web 服务（注意服务端绑定的是哪个端口记得加上） www.mczhangyi.top:6081 三、结尾 1.客户端连接服务端提示访问被拒绝，则需要服务端开放防火墙端口（学习的话全开就行了，生产环境除外）。 2.frps dashboard 通过浏览器查看 frp 的状态以及代理统计信息展示。 注：Dashboard 尚未针对大量的 proxy 数据展示做优化，如果出现 Dashboard 访问较慢的情况，请不要启用此功能。 需要在 服务端的 frps.ini 中指定 dashboard 服务使用的端口，即可开启此功能： 12345[common]dashboard_port = 7500 dashboard 用户名密码，默认都为 admin12345dashboard_user = admindashboard_pwd = admin 打开浏览器通过 http://[server_addr]:7500 访问 dashboard 界面，用户名密码默认为 admin。 3.其他功能请阅读 frp 中文文档：https://github.com/fatedier/frp/blob/master/README_zh.md","categories":[{"name":"内网穿透","slug":"内网穿透","permalink":"http://example.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"tags":[]},{"title":"apache 经常无法访问目录列表,显示 403 forbidden","slug":"apache 经常无法访问目录列表,显示 403 forbidden","date":"2020-05-04T08:56:48.000Z","updated":"2020-12-15T03:45:10.166Z","comments":true,"path":"2020/05/04/apache 经常无法访问目录列表,显示 403 forbidden/","link":"","permalink":"http://example.com/2020/05/04/apache%20%E7%BB%8F%E5%B8%B8%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8,%E6%98%BE%E7%A4%BA%20403%20forbidden/","excerpt":"","text":"apache经常无法访问目录列表,显示403 forbidden开发学习时，每次重置apache时，老是报错：Forbidden You don’t have permission to access / on this server.，真是气死人 我统计一下我碰到过的问题和解决办法 首先Linux的话网站目录权限直接改成755 解决办法1： 找到 /usr/local/apache/conf/httpd.conf 1Include conf/extra/httpd-vhosts.conf 由于vhosts刚装时没有配置过，将其注释了掉，然后重启apache就能访问了 解决办法2： 把index.php和|.php(PHP探针,没有的话就不用动)文件名修改掉 解决办法3： 这个困扰了我很久，改了apache配置文件也没用后来发现是根目录.htaccess文件被我设置成-indexs，改成+indexs就行了","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Web","slug":"服务器/Web","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Web/"}],"tags":[]},{"title":"PHP 去除 bom 头，JSON_decode () 返回 NULL，PHP 无法对字符串做处理","slug":"PHP 去除 bom 头，JSON_decode () 返回 NULL，PHP 无法对字符串做处理","date":"2020-05-04T08:56:48.000Z","updated":"2020-12-15T03:45:49.761Z","comments":true,"path":"2020/05/04/PHP 去除 bom 头，JSON_decode () 返回 NULL，PHP 无法对字符串做处理/","link":"","permalink":"http://example.com/2020/05/04/PHP%20%E5%8E%BB%E9%99%A4%20bom%20%E5%A4%B4%EF%BC%8CJSON_decode%20()%20%E8%BF%94%E5%9B%9E%20NULL%EF%BC%8CPHP%20%E6%97%A0%E6%B3%95%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%9A%E5%A4%84%E7%90%86/","excerpt":"","text":"今天碰到了一个json字符串无法处理，这是因为这个字符串带有bom头 去除bom头代码： 1$rs = trim($rs, &quot;\\xEF\\xBB\\xBF&quot;);","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"}],"tags":[]},{"title":"Larvel 操作 MongoDB（对内嵌数组增删改）","slug":"Larvel 操作 MongoDB（对内嵌数组增删改）","date":"2020-05-04T08:56:48.000Z","updated":"2020-12-15T03:46:31.012Z","comments":true,"path":"2020/05/04/Larvel 操作 MongoDB（对内嵌数组增删改）/","link":"","permalink":"http://example.com/2020/05/04/Larvel%20%E6%93%8D%E4%BD%9C%20MongoDB%EF%BC%88%E5%AF%B9%E5%86%85%E5%B5%8C%E6%95%B0%E7%BB%84%E5%A2%9E%E5%88%A0%E6%94%B9%EF%BC%89/","excerpt":"","text":"Larvel操作MongoDB（对内嵌数组增删改）PHP的MongoDB驱动中文文档 PHP的MongoDB驱动官方文档 有些细节都没写全，如想学习请阅读官方文档！ 普通的增删改查与mysql驱动操作一样12345678910111213141516171819增$rs = DB::collection(&#x27;集合名字&#x27;)-&gt;insertGetId($param);$rs = DB::collection(&#x27;集合名字&#x27;)-&gt;insert($param);删$rs = DB::collection(&#x27;集合名字&#x27;)-&gt;where([&quot;_id&quot;=&gt;1])-&gt;delete();改$rs = DB::collection(&#x27;集合名字&#x27;)-&gt;where([&quot;_id&quot;=&gt;1])-&gt;update([&#x27;name&#x27;=&lt;&#x27;遗失的美好&#x27;]);查$result = DB::collection(&#x27;集合名字&#x27;)-&gt;where([&quot;_id&quot;=&gt;1])-&gt;get();// 分页函数$results = DB::collection(&#x27;集合名字&#x27;)-&gt;paginate(10);// 这样也能做到分页 还有排序 orderBy() 排序函数，skip() 跳过几条 limit() 限制取出几条$rs = DB::collection(&#x27;集合名字&#x27;)-&gt;orderBy(&#x27;age&#x27;,&#x27;asc&#x27;)-&gt;skip(10))-&gt;limit(10)-&gt;get(); 对内嵌数组进行增删改，首先要知道：MongoDB操作符 12345678910111213141516171819202122增// 插入数组 $addToSet 插入时如果已经存在相同的则不插入 $rs = DB::collection(&#x27;user_files_folder&#x27;)-&gt;update([&#x27;$addToSet&#x27;=&gt;[&#x27;child&#x27;=&gt;[&#x27;name&#x27;=&gt;&#x27;二傻子&#x27;]])// 插入数组 $push 插入时如果已经存在相同的仍然插入$rs = DB::collection(&#x27;user_files_folder&#x27;)-&gt;update([&#x27;$push&#x27;=&gt;[&#x27;child&#x27;=&gt;[&#x27;name&#x27;=&gt;&#x27;二傻子&#x27;]])删$rs = DB::collection(&#x27;user_files_folder&#x27;)-&gt;update([&#x27;$pull&#x27;=&gt;[&#x27;child&#x27;=&gt;[&#x27;name&#x27;=&gt;&#x27;二傻子&#x27;]])改// 注意，这where条件如果需要多重结构则可以用.连接$set是修改操作符，对应修改对象（数组）修改对象如果需要多重结构也可以用.连接，这里的$符号代表对应的键（因为这里的数据结构是一个数组，$代表对应的序号，也可以写死成 0-9之类的数字）DB::collection(&#x27;stock&#x27;)-&gt;where([&#x27;info.id&#x27;=&gt;&quot;118b110212&quot;])-&gt;update([ $set&#x27;=&gt;[ &#x27;info.$.id&#x27;=&gt;&quot;118b110jkjkjk&quot; ]]);","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"},{"name":"Laravel","slug":"后端/PHP/Laravel","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/Laravel/"}],"tags":[]},{"title":"git设置下载代理","slug":"git设置下载代理","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:23:34.433Z","comments":true,"path":"2020/04/04/git设置下载代理/","link":"","permalink":"http://example.com/2020/04/04/git%E8%AE%BE%E7%BD%AE%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%90%86/","excerpt":"","text":"因为某些原因，我们下载git clone GitHub特别慢 123456git clone https://github.com/zoujingli/ThinkAdmin.gitCloning into &#x27;ThinkAdmin&#x27;...remote: Enumerating objects: 663, done.remote: Counting objects: 100% (663/663), done.remote: Compressing objects: 100% (483/483), done.Receiving objects: 1% (389/32521), 68.01 KiB | 6.00 KiB/s 这时候就需要一个代理，不然下载要等到明年，首先你要有一台代理服务器（看看网上有没有好心人共享），然后一般windows代理的端口是1080，看你软件自己的设置，这里我用的是V2XXX 12345678910111213inbounds&quot;: [ &#123; &quot;tag&quot;: &quot;proxy&quot;, &quot;port&quot;: 1080, &quot;listen&quot;: &quot;127.0.0.1&quot;, &quot;protocol&quot;: &quot;socks&quot;, &quot;sniffing&quot;: &#123; &quot;enabled&quot;: true, &quot;destOverride&quot;: [ &quot;http&quot;, &quot;tls&quot; ] &#125;, 然后命令行输入，注意git没有https代理，http包含了https，网上的教程都有误，而且地址不能加单引号 1git config --global http.proxy socks5://127.0.0.1:1080 查看所有代理 1git config --global --list 取消代理 1git config --global --unset http.proxy 查看成果，这速度杠杠的 12345Cloning into &#x27;ThinkAdmin&#x27;...remote: Enumerating objects: 663, done.remote: Counting objects: 100% (663/663), done.remote: Compressing objects: 100% (483/483), done.Receiving objects: 14% (4553/32521), 4.90 MiB | 990.00 KiB/s","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[]},{"title":"MySQL int类型长度的意义是什么","slug":"MySQL int类型长度的意义是什么","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:24:16.483Z","comments":true,"path":"2020/04/04/MySQL int类型长度的意义是什么/","link":"","permalink":"http://example.com/2020/04/04/MySQL%20int%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"当我们设置int类型时，可以设置int(11)，给int一个长度，一直以来都是认为mysql的int储存的值的长度与设置的int长度有关，如int(3)表示只能储存3位数字int(11)能存储11位数字。其实这根本就是大错特错。int永远只占4个字节，范围也不变（无符号除外） 其实int(1)和int(255)的范围是不变的，完全一模一样，那么长度的意义是什么呢，查了半天资料，最终想明白了，这个长度需要配合zerofill来使用，当设置了zerofill属性时，比如int(3)，那么储存一个1时，会自动填充到3位：001 ，这个在某些使用场景是有用的，int(5)就是: 00001 那么其他类型呢？tinyint跟int是一样的，而char、varchar等字符类型则确确实实表示字节大小范围，在UTF-8编码下，char(1)则表示只能存1个字符（汉字），char(5)则表示只能存5个字符（汉字） 官方手册：点我前往以上","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[]},{"title":"open_basedir() restrictijon in effect. FIle()","slug":"open_basedir() restrictijon in effect. FIle() ","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:25:21.817Z","comments":true,"path":"2020/04/04/open_basedir() restrictijon in effect. FIle() /","link":"","permalink":"http://example.com/2020/04/04/open_basedir()%20restrictijon%20in%20effect.%20FIle()%20/","excerpt":"","text":"宝塔里Laravel或thinkphp框架报Warning: require(): open_basedir() restrictijon in effect. FIle() 错误 open_basedir是PHP限制访问文件夹的配置参数，宝塔里自动配置了.user.ini，但是目录限制到了public，我们需要将其改到项目根目录打开 项目根目录/public/.user.ini文件 1open_basedir=/www/wwwroot/zmxyphp/public/:/tmp/:/proc/ 把public删除 1open_basedir=/www/wwwroot/zmxyphp/:/tmp/:/proc/ 重启PHP，OK！","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"服务器/Linux","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/"},{"name":"宝塔","slug":"服务器/Linux/宝塔","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/%E5%AE%9D%E5%A1%94/"}],"tags":[]},{"title":"PHP扫描图片转点阵 二维码转点阵","slug":"PHP扫描图片转点阵 二维码转点阵","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:25:48.102Z","comments":true,"path":"2020/04/04/PHP扫描图片转点阵 二维码转点阵/","link":"","permalink":"http://example.com/2020/04/04/PHP%E6%89%AB%E6%8F%8F%E5%9B%BE%E7%89%87%E8%BD%AC%E7%82%B9%E9%98%B5%20%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%BD%AC%E7%82%B9%E9%98%B5/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132/** * 图片转点阵（黑白） * @param string $imgPath * @return array */ function imgToLattice(string $imgPath): array &#123; $size = getimagesize($imgPath);// 得到图片的信息 $im = imagecreatefrompng($imgPath);// 創建一張圖片 // 储存二进制数组 $lattice = []; $white = [ &#x27;red&#x27; =&gt; 255, &#x27;green&#x27; =&gt; 255, &#x27;blue&#x27; =&gt; 255, &#x27;alpha&#x27; =&gt; 0, ]; for ($i = 0; $i &lt; $size[1]; ++ $i) &#123; $lattice[$i] = &#x27;&#x27;; for ($j = 0; $j &lt; $size[0]; ++$j) &#123; $rgb = imagecolorat($im, $j, $i); //取得某像素的颜色索引值 $rgbArr = imagecolorsforindex($im, $rgb); if ($white === $rgbArr)&#123; $lattice[$i] .= 0; &#125;else&#123; $lattice[$i] .= 1; &#125; &#125; &#125; return [$lattice, $size]; &#125; 注解： 1$rgbArr = imagecolorsforindex($im, $rgb); 这里返回一个RGB数组，跟$white数组一样，我因为二维码只有黑白，所以这里只做了黑白判断，黑就是1，白就是0，如果你的图片支持三种级以上，这里可以做判断，拼接其他数字 12345if ($white === $rgbArr)&#123; $lattice[$i] .= 0;&#125;else&#123; $lattice[$i] .= 1;&#125; 打印出来效果：转成HTML：参考代码：$this-&gt;image就上面PHP生成的数据，替换成自己的就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpnamespace Lattice\\LatticePck;/** * 点阵输出类 * Class LatticeOutput */class LatticeOutput extends Lattice&#123; /** * 二进制输出方法 HTML 把当前视图输出 * * @return string */ function getBinaryOutHtml(): string &#123; $str=&quot;&lt;html&gt;&lt;body&gt;&lt;div class=&#x27;k&#x27;&gt;&quot;; foreach ($this-&gt;image as $item) &#123; $str .= $this-&gt;getBinaryOutRow($item); &#125; $str .= &quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;; return $str; &#125; /** * 二进制输出方法 HTML 输出一行视图 * @param string $string * @return string */ function getBinaryOutRow(string $string): string &#123; $strLen = mb_strlen($string); $html = [ &quot;&lt;div&gt;&lt;/div&gt;&quot;, &quot;&lt;div class=&#x27;h&#x27;&gt;&lt;/div&gt;&quot;, ]; $str=&quot;&lt;div class=&#x27;g&#x27;&gt;&quot;; for($i=0;$i&lt;$strLen;$i++) &#123; $str .= $html[$string[$i]]; &#125; $str.=&quot;&lt;/div&gt;&quot;; return $str; &#125; public function getHtml() &#123; echo &quot;&lt;!DOCTYPE\\&quot;&gt; &lt;html xmlns=\\&quot;http://www.w3.org/1999/xhtml\\&quot;&gt; &lt;head&gt; &lt;meta name=\\&quot;viewport\\&quot; content=\\&quot;width=device-width,user-scalabl e=no\\&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;style&gt; .k &#123; margin: 0px; padding: 0px; width: 296px; height:128px; background-color: #F8F8F8; float: none; border: 2px solid #999999; &#125; .g &#123; margin: 0px; padding: 0px; width: 100%; float: none; height: 1px; &#125; .h&#123; background-color: #000000; &#125; .g div&#123; margin: 0px; padding: 0px; width: 1px; float: left; height: 1px; position: relative; &#125; .g div.h&#123; background-color: #000000; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&quot;; &#125; public function getFoot() &#123; echo &#x27;&lt;/body&gt; &lt;/html&gt;&#x27;; &#125;&#125;$lattice = new LatticeOutput();$lattice-&gt;getHtml();echo $lattice-&gt;getBinaryOutHtml();$lattice-&gt;getFoot();","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"图片","slug":"后端/PHP/图片","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/%E5%9B%BE%E7%89%87/"}],"tags":[]},{"title":"PHP设计模式之观察者模式","slug":"PHP设计模式之观察者模式","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:26:38.539Z","comments":true,"path":"2020/04/04/PHP设计模式之观察者模式/","link":"","permalink":"http://example.com/2020/04/04/PHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"使用场景假设项目经理让我们写了一个登陆接口，咔咔擦擦写完了 第二天让我们加入统计登陆次数，然后在后面加代码 第三天让我们判断登陆地区，又在后面加代码 第四天让我们在用户登陆后推送活动，再再后面加代码 第N天，这个接口已经杂乱到没人想维护了 我们需要让项目保持高内聚低耦合，就可以用到观察者模式（也不是非要，看需求） 概念观察者，观察者，首先要有个被人观察的角色，这是唯一的，然后会有无数个观察者去看她，可以说是一群人在围观一个人，既然有无数个观众，那总得有个东西记录有哪些观察者，那就应该有一个类似于数组一样来储存所有观察者，总结就是一个被观察者，无数个观察者，再有一个容器记录 代码示例 接口示例123456789// 主题接口interface Subject&#123; public function register(Observer $observer); public function notify();&#125;// 观察者接口interface Observer&#123; public function watch();&#125; Subject就是被观察者，Observer就是观众，也就是观察者 被观察者1234567891011121314// 被观察者class Action implements Subject&#123; public $_observers=array(); public function register(Observer $observer)&#123; $this-&gt;_observers[]=$observer; &#125; public function notify()&#123; foreach ($this-&gt;_observers as $observer) &#123; $observer-&gt;watch(); &#125; &#125; &#125; Action实现了被观察者接口，他现在就是被观察者，再定义一个$_observers数组，他就是记录观众的容器了。首先实现register方法，用它传入一个观察者，然后塞到数组里，再实现notify()方法，它会遍历容器数组，执行每个观察者的watch()方法。 观察者12345678910111213141516// 观察者class Cat implements Observer&#123; public function watch()&#123; echo &quot;Cat watches TV&lt;hr/&gt;&quot;; &#125; &#125; class Dog implements Observer&#123; public function watch()&#123; echo &quot;Dog watches TV&lt;hr/&gt;&quot;; &#125; &#125; class People implements Observer&#123; public function watch()&#123; echo &quot;People watches TV&lt;hr/&gt;&quot;; &#125; &#125; 这里定义了三个观察者，全都实现了Observer接口，前面的Subject会循环调用每个观察者的watch()方法，所以我们需要实现每个观察者的watch()方法。 调用 123456 // 应用实例$action=new Action();$action-&gt;register(new Cat());$action-&gt;register(new People());$action-&gt;register(new Dog());$action-&gt;notify(); 首先new被观察者对象，执行它的register()方法，把每个观察者都放入容器数组，最后执行notify()方法，通知所有观察者执行自己的方法。 PHP原生自带的观察者模式PHP有自带的观察者模式 splsubject接口 - 被观察者 Observer接口 - 观察者 SplObjectStorage对象 - 容器 首先我们有一个用户登录类 123456class user&#123; public function login() &#123; echo &#x27;登录完毕&#x27; &#125; 让他实现splsubject接口成为被观察者。 首先在构造函数里，让他new SplObjectStorag()对象并赋值到属性上方便后面调用 实现attach()方法，用来注册观察者 实现detach()方法，用来删除观察者 实现notify()方法，用来遍历容器，调用每个观察者的update方法(必须是update) rewind方法是容器指针重置到最开始，valid方法检测容器是否遍历完成并返回布尔，current方法是获取当前的观察者，next方法是将指针后移一位 修改login()方法，在里面调用notify()来通知观察者事件完成了123456789101112131415161718192021222324252627282930313233343536class user implements splsubject&#123; protected $observer = null; public function __construct() &#123; $this-&gt;observer = new SplObjectStorage(); &#125; public function login() &#123; $this-&gt;notify(); echo &#x27;登录完毕&#x27;; &#125; public function attach(SplObserver $observer) &#123; $this-&gt;observer-&gt;attach($observer); &#125; public function detach(SplObserver $observer) &#123; $this-&gt;observer-&gt;detach($observer); &#125; public function notify() &#123; $this-&gt;observer-&gt;rewind(); while ($this-&gt;observer-&gt;valid()) &#123; $observer = $this-&gt;observer-&gt;current(); $observer-&gt;update($this); $this-&gt;observer-&gt;next(); &#125; &#125;&#125; 观察者每个观察者实现SplObserver接口，并实现update()方法 12345678910111213class cat implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo &#x27;小猫叫一下&#x27;; &#125;&#125;class dog implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo &#x27;小狗吼一声&#x27;; &#125;&#125; 应用12345// 实时观察$user = new user();$user-&gt;attach(new cat());$user-&gt;attach(new dog());$user-&gt;login();","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"设计模式","slug":"后端/PHP/设计模式","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"Vue router 使用 History 模式导致页面请求 404","slug":"Vue router 使用 History 模式导致页面请求 404","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:27:25.765Z","comments":true,"path":"2020/04/04/Vue router 使用 History 模式导致页面请求 404/","link":"","permalink":"http://example.com/2020/04/04/Vue%20router%20%E4%BD%BF%E7%94%A8%20History%20%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%87%B4%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%20404/","excerpt":"","text":"vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 1234const router = new VueRouter(&#123; mode: &#x27;history&#x27;, routes: [...]&#125;) 当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，也好看！ 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 后端配置例子注意：下列示例假设你在根目录服务这个应用。如果想部署到一个子目录，你需要使用 Vue CLI 的 publicPath 选项 和相关的 router base property。你还需要把下列示例中的根目录调整成为子目录 (例如用 RewriteBase /name-of-your-subfolder/ 替换掉 RewriteBase /)。 Apache12345678&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase &#x2F; RewriteRule ^index\\.html$ - [L] RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule .&#x2F;index.html [L]&lt;&#x2F;IfModule&gt; 除了 mod_rewrite，你也可以使用 FallbackResource。 nginx1234location &#x2F; &#123; try_files $uri $uri&#x2F; &#x2F;index.html;&#125; 原生 Node.js1234567891011121314151617181920const http &#x3D; require(&#39;http&#39;)const fs &#x3D; require(&#39;fs&#39;)const httpPort &#x3D; 80http.createServer((req, res) &#x3D;&gt; &#123; fs.readFile(&#39;index.htm&#39;, &#39;utf-8&#39;, (err, content) &#x3D;&gt; &#123; if (err) &#123; console.log(&#39;We cannot open &quot;index.htm&quot; file.&#39;) &#125; res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;html; charset&#x3D;utf-8&#39; &#125;) res.end(content) &#125;)&#125;).listen(httpPort, () &#x3D;&gt; &#123; console.log(&#39;Server listening on: http:&#x2F;&#x2F;localhost:%s&#39;, httpPort)&#125;) #基于 Node.js 的 Express对于 Node.js/Express，请考虑使用 connect-history-api-fallback 中间件。 #Internet Information Services (IIS) 安装 IIS UrlRewrite 在你的网站根目录中创建一个 web.config 文件，内容如下： 123456789101112131415161718&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;system.webServer&gt; &lt;rewrite&gt; &lt;rules&gt; &lt;rule name&#x3D;&quot;Handle History Mode and custom 404&#x2F;500&quot; stopProcessing&#x3D;&quot;true&quot;&gt; &lt;match url&#x3D;&quot;(.*)&quot; &#x2F;&gt; &lt;conditions logicalGrouping&#x3D;&quot;MatchAll&quot;&gt; &lt;add input&#x3D;&quot;&#123;REQUEST_FILENAME&#125;&quot; matchType&#x3D;&quot;IsFile&quot; negate&#x3D;&quot;true&quot; &#x2F;&gt; &lt;add input&#x3D;&quot;&#123;REQUEST_FILENAME&#125;&quot; matchType&#x3D;&quot;IsDirectory&quot; negate&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;conditions&gt; &lt;action type&#x3D;&quot;Rewrite&quot; url&#x3D;&quot;&#x2F;&quot; &#x2F;&gt; &lt;&#x2F;rule&gt; &lt;&#x2F;rules&gt; &lt;&#x2F;rewrite&gt; &lt;&#x2F;system.webServer&gt;&lt;&#x2F;configuration&gt; #Caddy12345rewrite &#123; regexp .* to &#123;path&#125; &#x2F;&#125; #Firebase 主机在你的 firebase.json 中加入： 123456789101112&#123; &quot;hosting&quot;: &#123; &quot;public&quot;: &quot;dist&quot;, &quot;rewrites&quot;: [ &#123; &quot;source&quot;: &quot;**&quot;, &quot;destination&quot;: &quot;&#x2F;index.html&quot; &#125; ] &#125;&#125; 警告给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。 1234567const router &#x3D; new VueRouter(&#123; mode: &#39;history&#39;, routes: [ &#123; path: &#39;*&#39;, component: NotFoundComponent &#125; ]&#125;) 或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 Vue 服务端渲染文档。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Vue","slug":"前端/JavaScript/Vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/Vue/"}],"tags":[]},{"title":"Vue 使用预渲染代替 SSR","slug":"Vue 使用预渲染代替 SSR","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:27:51.286Z","comments":true,"path":"2020/04/04/Vue 使用预渲染代替 SSR/","link":"","permalink":"http://example.com/2020/04/04/Vue%20%E4%BD%BF%E7%94%A8%E9%A2%84%E6%B8%B2%E6%9F%93%E4%BB%A3%E6%9B%BF%20SSR/","excerpt":"","text":"页面渲染方式前段时间了解到页面有几种渲染方式：SPA SSR，以前写的一个网站但是用的渲染方式是SPA，导致搜索引擎爬虫抓不到任何信息，对SEO优化不很好，本想改成SSR，但是改动配置很多，弄来弄去怕影响开发，今天在Vue官网看到预渲染，今天试了下，感觉是一个折中的方法，而且配置改动不大，大家可以试试 什么是服务器端渲染 (SSR)？Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。 为什么使用服务器端渲染 (SSR)？与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于： 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。 服务器端渲染 vs 预渲染 (SSR vs Prerendering)如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。 如果你使用 webpack，你可以使用 prerender-spa-plugin 轻松地添加预渲染。它已经被 Vue 应用程序广泛测试 - 事实上，作者是 Vue 核心团队的成员。 使用方法 vue-router必须是history模式1234const router = new VueRouter(&#123; mode: &#x27;history&#x27;, routes: [...]&#125;) 安装预渲染核心：prerender-spa-plugin1yarn add prerender-spa-plugin -D 在vue.config.js配置（低版本vue写在build/webpack.prod.conf.js）12345678910111213141516171819202122232425const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports=&#123; // 因为高版本Vue将配置文件整合到了vue.config.js,所以原先写在webpack配置里的都需要写在configureWebpack里 configureWebpack: &#123; // plugins插件里书写 plugins: [ new PrerenderSPAPlugin(&#123; // 生成文件的路径，这个目录只能有一级。若目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动 staticDir: path.join(__dirname, &#x27;./dist&#x27;), // 对应自己的路由文件 routes: [ &#x27;/&#x27;, &#x27;/article&#x27;], // 若没有这段则不会进行预编译 renderer: new Renderer(&#123; inject: &#123; foo: &#x27;bar&#x27; &#125;, headless: false, // 在 main.js 中 document.dispatchEvent(new Event(&#x27;render-event&#x27;))，两者的事件名称要对应上。 renderAfterDocumentEvent: &#x27;render-event&#x27; &#125;) &#125;), ] &#125;&#125; 在mian.js配置，在mounted函数里增加 document.dispatchEvent(new Event(‘render-event’))123456789new Vue(&#123; el: &#x27;#app&#x27;, router, store, render:h=&gt;h(App), mounted()&#123; document.dispatchEvent(new Event(&#x27;render-event&#x27;)) &#125;&#125;) yarn run build打包项目，看到自己的页面被提前生成就OK了 安装vue-meta-info插件，网页meta标签 yarn安装1yarn add vue-meta-info 在mian.js配置12import MetaInfo from &#x27;vue-meta-info&#x27; Vue.use(MetaInfo) 在XXOO.vue文件中配置123456789101112131415export default &#123; &#x2F;&#x2F; 这些代码会转成网页的meta标签里的内容 metaInfo: &#123; title: &#39;标题&#39;, meta: [ &#123; name: &#39;keywords&#39;, content: &#39;关键字&#39; &#125;, &#123; name: &#39;description&#39;, content: &#39;网页描述&#39; &#125; ] &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Vue","slug":"前端/JavaScript/Vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/Vue/"}],"tags":[]},{"title":"axios 拦截器 的使用方法","slug":"axios 拦截器 的使用方法","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:28:29.062Z","comments":true,"path":"2020/04/04/axios 拦截器 的使用方法/","link":"","permalink":"http://example.com/2020/04/04/axios%20%E6%8B%A6%E6%88%AA%E5%99%A8%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"有时候我们需要对axios发送的请求做统一处理，这里就需要使用拦截器 首先要创建一个axios示例12345import axios from &#x27;axios&#x27;const $http = axios.create(&#123; baseURL: &#x27;/api/&#x27;, timeout: 5000 // request timeout&#125;) 请求拦截器,在请求发起之前拦截处理1234567891011// http response 拦截器$http.interceptors.response.use( config =&gt; &#123; //拦截请求，做统一处理 console.log(&#x27;即将请求数据&#x27;); console.log(config); return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;) 响应拦截器,在接口返回数据后 响应处理之前 拦截处理12345678910111213// http response 拦截器$http.interceptors.response.use( response =&gt; &#123; //拦截响应，做统一处理 console.log(&#x27;数据请求成功&#x27;); console.log(response); const res = response.data return res &#125;, //接口错误状态处理，也就是说无响应时的处理 error =&gt; &#123; return Promise.reject(error.response.status) // 返回接口返回的错误信息&#125;) 之后就可以把这个axios示例暴露出去，正常使用即可1export default $http","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"axios","slug":"前端/JavaScript/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/axios/"}],"tags":[]},{"title":"MySQL（Oracle）模糊查询 使用 instr () 替代 like 提升效率","slug":"MySQL（Oracle）模糊查询 使用 instr () 替代 like 提升效率","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:29:05.809Z","comments":true,"path":"2020/04/04/MySQL（Oracle）模糊查询 使用 instr () 替代 like 提升效率/","link":"","permalink":"http://example.com/2020/04/04/MySQL%EF%BC%88Oracle%EF%BC%89%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%20%E4%BD%BF%E7%94%A8%20instr%20()%20%E6%9B%BF%E4%BB%A3%20like%20%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87/","excerpt":"","text":"大家都知道like的效率很低，数据量大就会很慢，今天发现了一个内置函数instr()效率比like高 1SELECT * FROM msg_list WHERE title LIKE &#x27;%涂山%&#x27; 可以替换为： 1SELECT * FROM msg_list WHERE INSTR(title,&#x27;涂山&#x27;) &gt; 0 在 ThinkPHP / Laravel中使用的方法有： 使用 whereRaw()执行原生INSTR() 修改构造查询器（不太推荐，不过用起来方便）1项目根目录\\thinkphp\\library\\think\\db\\Builder.php 1234MsgList::where([ &#x27;title&#x27; =&gt; [&#x27;instr&#x27;,&#x27;涂山&#x27;]]) -&gt;select();","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[]},{"title":"PHP7合并运算符和条件运算符的作用和区别","slug":"PHP7合并运算符和条件运算符的作用和区别","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:30:21.149Z","comments":true,"path":"2020/04/04/PHP7合并运算符和条件运算符的作用和区别/","link":"","permalink":"http://example.com/2020/04/04/PHP7%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"我们经常要写类似于这种判断代码 12// 判断是否存在变量$a = isset($b) ? $b : $c; 12// 判断变量是否为空$a = !empty($b) ? $b : $c; PHP7有了新语法糖，进行简化（PHP版本必须大于7） 12// 判断是否存在变量$a = $b ?? $c; // 等同于 $a = isset($b) ? $b : $c; 12// 判断变量是否为空$a = $b ?: $c; // 等同于 $a = !empty($b) ? $b : $c; 他们的区别在 null合并运算符：?? 判断变量不存在或为NULL null条件运算符：?: 则还会判断变量是否为空12345$a = [];print_r($a ?? &#x27;走了这边&#x27;);// []print_r($a ?: &#x27;走了这边&#x27;);// &#x27;走了这边&#x27; ?? 还会判断是否为NULL123$a = null;print_r($a ?? &#x27;走了这边&#x27;);// 走了这边","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"}],"tags":[]},{"title":"ThinkPHP 使用命令行 (cli) think 调用","slug":"ThinkPHP 使用命令行 (cli) think 调用 ","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:30:56.632Z","comments":true,"path":"2020/04/04/ThinkPHP 使用命令行 (cli) think 调用 /","link":"","permalink":"http://example.com/2020/04/04/ThinkPHP%20%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%20(cli)%20think%20%E8%B0%83%E7%94%A8%20/","excerpt":"","text":"在某些场景里，我们需要在命令行中调用代码 首先，在application\\command目录(目录没有则创建)下新建hello.php： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace app\\command;use think\\console\\Command;use think\\console\\Input;use think\\console\\input\\Argument;use think\\console\\input\\Option;use think\\console\\Output;use think\\Request;class hello extends Command &#123; /** * 重写configure * &#123;@inheritdoc&#125; */ protected function configure() &#123; $this // 命令的名字（&quot;think&quot; 后面的部分） -&gt;setName(&#x27;hello&#x27;) // 配置一个参数 使用$input-&gt;getArgument(&#x27;username&#x27;)获取 // -&gt;addArgument(&#x27;username&#x27;) // 运行 &quot;php think list&quot; 时的简短描述 -&gt;setDescription(&#x27;定时任务微服务.&#x27;) // 运行命令时使用 &quot;--help&quot; 选项时的完整命令描述 -&gt;setHelp(&quot;定时任务微服务 无参数&quot;); &#125; /** * * 重写execute * * &#123;@inheritdoc&#125; * * @param Input $input * @param Output $output */ protected function execute(Input $input, Output $output) &#123; echo &#x27;hello world&#x27;; &#125;&#125; 修改application/command.php（没有则创建） 1234&lt;?phpreturn [ &quot;app\\command\\hello&quot;,]; cd到项目根目录，在命令行输入 1php think hello OK,成功调用 1hello world ThinkPHP6修改了逻辑，看这里：https://www.kancloud.cn/manual/thinkphp6_0/1037651","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"ThinkPHP","slug":"后端/PHP/ThinkPHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/ThinkPHP/"}],"tags":[]},{"title":"phpStorm 如何用 FTP,SSH 连接到虚拟机 Linux 系统？","slug":"phpStorm 如何用 FTP,SSH 连接到虚拟机 Linux 系统？","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:31:44.214Z","comments":true,"path":"2020/04/04/phpStorm 如何用 FTP,SSH 连接到虚拟机 Linux 系统？/","link":"","permalink":"http://example.com/2020/04/04/phpStorm%20%E5%A6%82%E4%BD%95%E7%94%A8%20FTP,SSH%20%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%20Linux%20%E7%B3%BB%E7%BB%9F%EF%BC%9F/","excerpt":"","text":"首先，需要你新建一个目录，用于存放从服务器下载的项目。然后用phpstorm左上角 file-&gt;open打开。然后 这里测试是否连接上ftp如果出现了这种情况，把俩行都去除，然后在Local path，选择你要下载到本地的目录。没有出现就跳过这张图。 我遇到的问题： Q：Download from CenterOS failed: could not change to work directory A：出现这个问题可能是因为ftp的路径写错了，在你填写 root path 的时候不要写路径，因为你的ftp的账号权限已经到你的文件夹目录了，比如www/html/test. 要是你在root path 这在写一个路径就成为了 www/html/test/www/html/test. 所以就会报错！！","categories":[{"name":"IDE","slug":"IDE","permalink":"http://example.com/categories/IDE/"},{"name":"IDEA","slug":"IDE/IDEA","permalink":"http://example.com/categories/IDE/IDEA/"}],"tags":[]},{"title":"apache 与 Nginx 隐藏 index.php 报错 No input file specified. 解决办法 设置伪静态","slug":"apache 与 Nginx 隐藏 index.php 报错 No input file specified. 解决办法 设置伪静态","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:33:02.452Z","comments":true,"path":"2020/04/04/apache 与 Nginx 隐藏 index.php 报错 No input file specified. 解决办法 设置伪静态/","link":"","permalink":"http://example.com/2020/04/04/apache%20%E4%B8%8E%20Nginx%20%E9%9A%90%E8%97%8F%20index.php%20%E6%8A%A5%E9%94%99%20No%20input%20file%20specified.%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20%E8%AE%BE%E7%BD%AE%E4%BC%AA%E9%9D%99%E6%80%81/","excerpt":"","text":"Apache在.htaccess中修改（如果是框架，则在public下的.htaccess）1234567&lt;IfModule mod_rewrite.c&gt;Options +FollowSymlinks -MultiviewsRewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]&lt;/IfModule&gt; Nginx在nginx.conf里增加一行12345location / &#123; if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=/$1 last; &#125;&#125; OJBK","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Web","slug":"服务器/Web","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Web/"}],"tags":[]},{"title":"axios baseURL 的使用方法","slug":"axios baseURL 的使用方法","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:33:43.028Z","comments":true,"path":"2020/04/04/axios baseURL 的使用方法/","link":"","permalink":"http://example.com/2020/04/04/axios%20baseURL%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"每次Api都要填写域名，可以设置一个baseUrl，这样少写点代码，而且后面更换域名时，生产环境和开发环境统一时很有用 qs.stringify将参数格式化成QueryString，可以不设置 在main.js中修改：12345Vue.prototype.axios = axios.create(&#123; baseURL:&#x27;/api/&#x27;, transformRequest: [//对数据转换成类似get传参的模式 data =&gt; qs.stringify(data) ]&#125;) 这样axios在发出请求时会自动加上baseURL","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"axios","slug":"前端/JavaScript/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/axios/"}],"tags":[]},{"title":"Vue 跨域问题解决办法 Vue 配置防止跨域 nginx 重定向防止跨域","slug":"Vue 跨域问题解决办法 Vue 配置防止跨域 nginx 重定向防止跨域","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:36:13.252Z","comments":true,"path":"2020/04/04/Vue 跨域问题解决办法 Vue 配置防止跨域 nginx 重定向防止跨域/","link":"","permalink":"http://example.com/2020/04/04/Vue%20%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20Vue%20%E9%85%8D%E7%BD%AE%E9%98%B2%E6%AD%A2%E8%B7%A8%E5%9F%9F%20nginx%20%E9%87%8D%E5%AE%9A%E5%90%91%E9%98%B2%E6%AD%A2%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"前后端分离不可避免会遇到跨域问题，可把我烦的想砍人，现在总结几个解决办法让后人不走歪路环境： Vue-cli 4x 本地开发跨域问题 - 配置devServer 打开根目录的vue.config.js(没有则创建，vue以前的版本有的是写在config/index.js，有的写在webpack.config.js，4x版本统一在vue.config.js)，写入： 1234567891011121314151617module.exports = &#123; devServer:&#123; host: &#x27;localhost&#x27;, // Vue开发项目启动域名 port: 8080, // 端口 https: false, // 是否是https open:false, proxy:&#123; &#x27;/apiDev&#x27;:&#123; target: &#x27;http://api.zmxy.com&#x27;, // 后端API changeOrigin: true, pathRewrite:&#123; &#x27;^/apiDev&#x27;:&#x27;&#x27; // 以apiDev作为前缀 &#125; &#125; &#125; &#125;&#125; npm run serve 重新编译项目，以apiDev开头的URL就会自动转发到http://api.zmxy.comaxios使用：1234this.axios. get(&#x27;/apiDev/index/index/getDetail&#x27;,&#123; params: &#123;id:id&#125; &#125;) Nginx重定向转发防止跨域 编辑Nginx配置文件 12345location /api &#123; rewrite ^.+api/?(.*)$ /$1 break; //可选参数，正则验证地址 include uwsgi_params; //可选参数，uwsgi是服务器和服务端应用程序的通信协议，规定了怎么把请求转发给应用程序和返回 proxy_pass https://www.api.com; // 此处修改为自己的请求地址，必填&#125; 重启Nginxaxios使用：1234this.axios. get(&#x27;/api/index/index/getDetail&#x27;,&#123; params: &#123;id:id&#125; &#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Vue","slug":"前端/JavaScript/Vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/Vue/"}],"tags":[]},{"title":"Vue 跨域问题解决办法 Vue 配置防止跨域 nginx 重定向防止跨域","slug":"解决 win10 命令行下运行 python 弹出 Windows 应用商店","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:36:50.713Z","comments":true,"path":"2020/04/04/解决 win10 命令行下运行 python 弹出 Windows 应用商店/","link":"","permalink":"http://example.com/2020/04/04/%E8%A7%A3%E5%86%B3%20win10%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8C%20python%20%E5%BC%B9%E5%87%BA%20Windows%20%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97/","excerpt":"","text":"前几天为了体验新版Edge，更新了win10，然后运行python命令结果跳出了win10商店(黑人问号？？？)于是乎查看了下环境变量，发现配置没有问题，我怀疑win10设置了某个变量导致覆盖了我的python,于是在cmd里运行1where python 输出： 12C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps\\python.exeD:\\Develop\\Program Files\\Python\\Python38\\python.exe 这个WindowsApps不是win10商店吗，什么时候给我加上的，网上查了下，应该是win10商店配置的环境变量方便用户去下载Microsoft store的python，这个我不需要，于是我去环境变量处，将我的python目录优先级放在WindowsApps优先级前面 把python目录放前面 重启CMD，OJBK 这里的%%是解析变量，可以在前面设置好，然后在path目录下把变量名前后加%就可以解析了PS:win10更新把我设置的变量全部换成路径了，这几个也是我刚刚加上的，逼死强迫症，以后再也不更新了","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python","slug":"后端/Python","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Python/"}],"tags":[]},{"title":"Linux 添加脚本开机自启动","slug":"Linux 添加脚本开机自启动","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:37:25.413Z","comments":true,"path":"2020/04/04/Linux 添加脚本开机自启动/","link":"","permalink":"http://example.com/2020/04/04/Linux%20%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%9C%AC%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/","excerpt":"","text":"新更新，直接编辑 /etc/rc.d/rc.local 即可 不在需要自己新建 1vim /etc/rc.d/rc.local 使用chkconfig 首先写一个脚本 1234#!/bin/sh#chkconfig:2345 80 90#decription:autostartnohup ~/frpc_linux_amd64 -t 7693dddbc9cc1413 -s 32 # mysql #!/bin/sh 是shell脚本的开头#chkconfig:2345 80 90 是设置启动优先级，首先你需要百度下Linux启动级别，这里脚本意思是：脚本应该在级别2、3、4、5中启动，它的开始优先级应该是20，它的停止优先级应该是80，这行没有也没事，会给默认优先级#decription:autostart 是脚本描述，不影响执行，非必须nohup XXX 是我自己需要执行的命令，这里文件路径必须是从根目录开始的绝对路径，不如找不到 将其移动到/etc/rc.d/init.d目录 1mv sf_ssh_frp.sh /etc/rc.d/init.d/sf_ssh_frp.sh 然后要赋予权限，不然无法执行 1chmod +x /etc/rc.d/init.d/sf_ssh_frp.sh 之后就是使用chkconfig来添加开机启动了 1chkconfig --add sf_ssh_frp.sh chkconfig 命令： 12345678chkconfig --add httpd # 添加服务，以便让chkconfig指令管理它chkconfig httpd on # 设置开机运行该服务，默认是设置2345等级开机运行服务chkconfig --list # 列出所有被chkconfig管理的服务chkconfig --add httpd # 添加指定的服务，让chkconfig指令管理它chkconfig --del httpd # 删除指定的服务，不再让chkconfig指令管理它chkconfig httpd on # 设置开机运行服务，需要先执行 --add 才能执行该命令chkconfig httpd off # 设置开机不运行服务，需要先执行 --add 才能执行该命令chkconfig --level 35 httpd on # 设置服务在等级3和5时开机运行服务，默认是设置2345等级开机运行服务 1234567chkconfig --list # 等级0：关机atop 0:off 1:off 2:off 3:off 4:off 5:off 6:off # 等级1：单用户模式/救援模式auditd 0:off 1:off 2:off 3:off 4:on 5:off 6:off # 等级2：无网络连接的多用户命令行模式crond 0:off 1:off 2:on 3:on 4:on 5:on 6:off # 等级3：有网络连接的多用户命令行模式ipset 0:off 1:off 2:on 3:on 4:on 5:on 6:off # 等级4：不可用iptables 0:off 1:off 2:off 3:off 4:on 5:off 6:off # 等级5：带图形界面的多用户模式mysql 0:off 1:off 2:on 3:on 4:on 5:on 6:off # 等级6：重启","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"服务器/Linux","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/"}],"tags":[]},{"title":"frp 实现内网穿透（Windows 版）","slug":"phpstorm 使用 Xdebug 调试代码","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:38:16.159Z","comments":true,"path":"2020/04/04/phpstorm 使用 Xdebug 调试代码/","link":"","permalink":"http://example.com/2020/04/04/phpstorm%20%E4%BD%BF%E7%94%A8%20Xdebug%20%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/","excerpt":"","text":"配置 frp 实现内网穿透frp 中文文档：https://github.com/fatedier/frp/blob/master/README_zh.md 一、frp 的作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 二、安装 frp 1. github下载地址：https://github.com/fatedier/frp/releases 公网、内网服务器都下载一份。 找到第一条，然后下载frp_windwos_amd64.zip这个(amd64是64系统,386是32位系统，现在电脑基本64位了)，比如图片上的frp_0.33.0_windows_amd64.zip 2、将frp_0.33.0_windows_amd64.zip解压至任意目录 3、进入解压目录这里所有 frpc 开头的文件都是客户端文件，所以全部删了，我们服务器只需要 frps 开头的文件 4、配置服务端（公网服务器）我们打开frps.ini（我用的notepad++编辑器，记事本也可以）注意配置文件不支持注释，请不要把汉字复制进去 123[common]bind_port = 7000 #与客户端绑定的进行通信的端口vhost_http_port = 6081 #访问客户端web服务自定义的端口号 保存然后打开cmd进入当前目录（cmd不会用自行百度），输入：frps.exe -c ./frps.ini，此时会提示网络防火墙安全警告，点允许提示 start frps success则服务启动成功警告：云服务器一定要开放端口，不会开放自行百度，图中的7000是frp绑定的默认端口要打开，另外一个是http（用不到可以删了） 至此服务端配置完成！5、配置客户端（内网服务器），首先删掉 frps 开头文件文件,然后再进行配置，编辑 frpc.ini注意配置文件不支持注释，请不要把汉字复制进去 123456789[common]server_addr = 155.94.169.143 #公网服务器ipserver_port = 7000 #与服务端bind_port一致[yclj]type = tcplocal_ip = 127.0.0.1local_port = 3389 # 3389是windows的远程连接端口remote_port = 24567 # 远程服务器端口（自定义） 保存然后执行windows 使用cmd或者powershell进入当前目录，执行 1.&#x2F;frpc.exe -c .&#x2F;frpc.ini 6、访问方式(1) 远程连接windows bind_post要绑定3389，其他的不行ip：155.94.169.143:24567 （这个是服务器开放的端口，映射本地的3389） 三、结尾 1.客户端连接服务端提示访问被拒绝，则需要服务端开放防火墙端口（学习的话全开就行了，生产环境除外）。 2.其他功能请阅读 frp 中文文档：https://github.com/fatedier/frp/blob/master/README_zh.md","categories":[{"name":"内网穿透","slug":"内网穿透","permalink":"http://example.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"tags":[]},{"title":"update-alternatives 使用详解","slug":"update-alternatives 使用详解","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:38:37.468Z","comments":true,"path":"2020/04/04/update-alternatives 使用详解/","link":"","permalink":"http://example.com/2020/04/04/update-alternatives%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"update-alternatives 命令用于处理 Linux 系统中软件版本的切换，使其多版本共存。alternatives 的管理目录 /etc/alternatives 。 alternatives 管理方式 1234$ ls -l /usr/bin/pythonlrwxrwxrwx 1 root root 24 1120 2017 /usr/bin/python -&gt; /etc/alternatives/python$ ls -l /etc/alternatives/pythonlrwxrwxrwx 1 root root 18 1121 2017 /etc/alternatives/python -&gt; /usr/bin/python2.7 python 这个可执行命令实际是一个链接，指向了 /etc/alternatives/python 。而这个也是一个链接，指向了 /usr/bin/python2.7 ，这才是最终的可执行文件。alternatives 实际上是通过软链接的方式对版本进行管理。语法： 123456789101112131415161718192021222324$ update-alternatives --help用法：update-alternatives [&lt;选项&gt; ...] &lt;命令&gt;命令： --install &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先级&gt; [--slave &lt;链接&gt; &lt;名称&gt; &lt;路径&gt;] ... 在系统中加入一组候选项。 --remove &lt;名称&gt; &lt;路径&gt; 从 &lt;名称&gt; 替换组中去除 &lt;路径&gt; 项。 --remove-all &lt;名称&gt; 从替换系统中删除 &lt;名称&gt; 替换组。 --auto &lt;名称&gt; 将 &lt;名称&gt; 的主链接切换到自动模式。 --display &lt;名称&gt; 显示关于 &lt;名称&gt; 替换组的信息。 --query &lt;名称&gt; 机器可读版的 --display &lt;名称&gt;. --list &lt;名称&gt; 列出 &lt;名称&gt; 替换组中所有的可用候选项。 --get-selections 列出主要候选项名称以及它们的状态。 --set-selections 从标准输入中读入候选项的状态。 --config &lt;名称&gt; 列出 &lt;名称&gt; 替换组中的可选项，并就使用其中哪一个，征询用户的意见。 --set &lt;名称&gt; &lt;路径&gt; 将 &lt;路径&gt; 设置为 &lt;名称&gt; 的候选项。 --all 对所有可选项一一调用 --config 命令。&lt;链接&gt; 是指向 /etc/alternatives/&lt;名称&gt; 的符号链接。(如 /usr/bin/pager)&lt;名称&gt; 是该链接替换组的主控名。(如 pager)&lt;路径&gt; 是候选项目标文件的位置。(如 /usr/bin/less)&lt;优先级&gt; 是一个整数，在自动模式下，这个数字越高的选项，其优先级也就越高。.......... 实例 display 参数显示关于 Python 替换组的信息1234567$ update-alternatives --display python python - 手动模式link best version is /usr/bin/python3.5链接目前指向 /usr/bin/python2.7link python is /usr/bin/python/usr/bin/python2.7 - 优先级 1/usr/bin/python3.5 - 优先级 2 选择候选项1$ update-alternatives --config python install 参数用于添加一个命令的link值1234567# 添加 python link$ update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2# 第一个参数: --install 表示向update-alternatives注册服务名。# 第二个参数: 注册最终地址，成功后将会把命令在这个固定的目的地址做真实命令的软链，以后管理就是管理这个软链；# 第三个参数: 服务名，以后管理时以它为关联依据。# 第四个参数: 被管理的命令绝对路径。# 第五个参数: 优先级，数字越大优先级越高。 remove 参数用于删除一个命令的link值，其附带的slave也将一起删除1$ update-alternatives –remove python /usr/bin/python2.7 转载于：https://www.jianshu.com/p/4d27fa2dce86","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"服务器/Linux","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/"}],"tags":[]},{"title":"Linux 虚拟机使用 xshell 连接 (debian、kali、CentOS)","slug":"Linux 虚拟机使用 xshell 连接 (debian、kali、CentOS)","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:38:57.108Z","comments":true,"path":"2020/04/04/Linux 虚拟机使用 xshell 连接 (debian、kali、CentOS)/","link":"","permalink":"http://example.com/2020/04/04/Linux%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%20xshell%20%E8%BF%9E%E6%8E%A5%20(debian%E3%80%81kali%E3%80%81CentOS)/","excerpt":"","text":"首先要确认ip地址，使用ifconfig或者ip addr查看IP地址（一般网卡名是eth0） 如果没有eth0或者ipv4的地址的话，需要开启网卡 确保vmware左上角–虚拟机–可移动设备–网络设备–设置中切换网络连接方式 NAT或者桥接模式 编辑/etc/network/interfaces文件 1vim /etc/network/interfaces 使用vim命令修改这个文件 eth0为dhcp模式(我设置静态IP老失败，还是动态分配吧) 重启网卡 123/etc/init.d/networking restartifconfig eth0 downifconfig eth0 up 开启SSH，首先打开配置文件 1vim /etc/ssh/sshd_config 需要找到 PasswordAuthentication 这一行，按”i”进入输入模式，去掉PasswordAuthentication前面的#号，如果后面是”no”则修改为”yes” wp保存后，输入service ssh start 开启ssh， 1service ssh start 1update-rc.d ssh enable # 设置ssh开机自启动 1update-rc.d ssh disabled # 关闭自启动 之后用Xshell连接linux就不用教了吧~~~","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"服务器/Linux","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/"}],"tags":[]},{"title":"PHP xml 转数组 数组转 xml 操作","slug":"PHP xml 转数组 数组转 xml 操作","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:40:09.969Z","comments":true,"path":"2020/04/04/PHP xml 转数组 数组转 xml 操作/","link":"","permalink":"http://example.com/2020/04/04/PHP%20xml%20%E8%BD%AC%E6%95%B0%E7%BB%84%20%E6%95%B0%E7%BB%84%E8%BD%AC%20xml%20%E6%93%8D%E4%BD%9C/","excerpt":"","text":"XML转数组 直接上代码 12345$path = &#x27;./data.xml&#x27;;$xml = simplexml_load_file($path);foreach($xml-&gt;children() as $child)&#123; echo $child&#125; simplexml_load_file() 函数把 XML 文档载入对象中。| file | 必需。规定要使用的 XML 文档。 || class | 可选。规定新对象的 class。 || options | 可选。规定附加的 Libxml 参数。 || ns | 可选。 || is_prefix | 可选。 |返回一个SimpleXMLElement 对象 如果是字符串怎么办？ 12$xml=simplexml_load_string($note);print_r($xml) simplexml_load_string() 函数转换形式良好的 XML 字符串为 SimpleXMLElement 对象。| data | 必需。规定形式良好的 XML 字符串。 || classname | 可选。规定新对象的 class。 |返回一个SimpleXMLElement 对象 我要的是数组，可不是对象啊SimpleXMLElement 对象转换数组,直接强转即可 1$array = (array)$SimpleXMLElement; 数组转XML 多维数组递归转换XML 1234567891011121314151617// 创建新的simpleXML实例，注入内存，确定根节点$xml = new SimpleXMLElement(&#x27;&lt;root/&gt;&#x27;);//数组转XMLfunction arrayToXml($obj, $array)&#123; foreach ($array as $k =&gt; $v) &#123; if(is_numeric($k)) $k = &#x27;item&#x27; . $k; if(is_array($v))&#123; $node = $obj-&gt;addChild($k); arrayToXml($node, $v); &#125;else&#123; $obj-&gt;addChild($k, htmlspecialchars($v)); &#125; &#125;&#125; 6.之后用Xshell连接linux就不用教了吧~~~","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"}],"tags":[]},{"title":"Web 服务器显示 no input file specified","slug":"Web 服务器显示 no input file specified","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:41:00.399Z","comments":true,"path":"2020/04/04/Web 服务器显示 no input file specified/","link":"","permalink":"http://example.com/2020/04/04/Web%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%BE%E7%A4%BA%20no%20input%20file%20specified/","excerpt":"","text":"今天部署服务器时，显示no input file specified，一度以为是Apache和Nginx的伪静态设置错误，又在另一个服务器试了下，发现没问题，应该是环境配置出了问题，切换了个PHP版本，发现可以了，对比两个版本的php.ini文件，发现以前修改过open_basedir open_basedir 将php所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开 将其注释后，问题解决","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Web","slug":"服务器/Web","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Web/"}],"tags":[]},{"title":"vue 踩坑-This dependency was not found","slug":"vue 踩坑-This dependency was not found","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:41:35.351Z","comments":true,"path":"2020/04/04/vue 踩坑-This dependency was not found/","link":"","permalink":"http://example.com/2020/04/04/vue%20%E8%B8%A9%E5%9D%91-This%20dependency%20was%20not%20found/","excerpt":"","text":"vue无法引入局部css- Vue @import Module not found今天用Vue-cli局部引入一个css，但是一直提示Module not found 或者 This dependency was not found 以为是自己依赖未安装好，装好了Loader也没用，才发现Vue的路径不是从入口文件开始算的，而是从当前组件位置，我一直以为是从main.js开始，才浪费了好多时间","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Vue","slug":"前端/JavaScript/Vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/Vue/"}],"tags":[]},{"title":"Swoole 问题总结","slug":"Swoole 问题总结","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:42:13.974Z","comments":true,"path":"2020/04/04/Swoole 问题总结/","link":"","permalink":"http://example.com/2020/04/04/Swoole%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"Swoole问题总结官方文档 – https://wiki.swoole.com/wiki/page/1.html 官方错误问题 – https://wiki.swoole.com/wiki/page/438.html 一.安装问题： 编译问题 (1) 今天部署PHP多版本共存，遇到编译失败error，没有找到php-config，在编译安装swoole时，./configure需要一些参数，完整如下： ./configure –with-php-config=/usr/local/php7/bin/php-config 后边路径请替换成自己的实际路径。 (2) make: *** [php_swoole_cxx.lo] 错误 1 在执行这一步时 1 错误：./configure --with-php-config=/www/server/php/72/bin/php 指定的是php-config文件，而不是php文件 1 正确：./configure --with-php-config=/www/server/php/72/bin/php-config","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"Swoole","slug":"后端/PHP/Swoole","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/Swoole/"}],"tags":[]},{"title":"PHP 操作 MongoDB","slug":"PHP 操作 MongoDB","date":"2020-04-04T08:56:48.000Z","updated":"2020-12-15T03:43:29.196Z","comments":true,"path":"2020/04/04/PHP 操作 MongoDB/","link":"","permalink":"http://example.com/2020/04/04/PHP%20%E6%93%8D%E4%BD%9C%20MongoDB/","excerpt":"","text":"PHP操作MongoDBPHP的MongoDB驱动中文文档：https://www.php.cn/manual/view/4.html PHP的MongoDB驱动官方文档：https://www.php.net/manual/zh/book.mongodb.php 有些细节都没写全，如想学习请阅读官方文档！ PHP连接MongoDB: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 创建连接$manager = new MongoDB\\Driver\\Manager(&#x27;mongodb://localhost:27017&#x27;);// MongoDB 写操作类$bulk = new MongoDB\\Driver\\BulkWrite;// 创建一个MongoDB ObjectId，如果传入的是字符串，它将尝试将其转化为ObjectId类型$id = new MongoDB\\BSON\\ObjectId();增删改查:// 增// MongoDB默认将 _id 当作主键，如果没有它会自动创建，所以这里的_id可以不填$bulk-&gt;insert([&#x27;_id&#x27;=&gt;new MongoDB\\BSON\\ObjectId, &#x27;name&#x27;=&gt;&#x27;我是遗失的美好灬&#x27;, &#x27;age&#x27;=&gt;18]);// executeBulkWrite() 执行一个或多个写操作 参数一 是命名空间（ 数据库.集合），参数二 是写操作对象 BulkWrite$result = $manager-&gt;executeBulkWrite(&#x27;cxfs.hahah&#x27;, $bulk);// 改/* update()向批量添加更新操作 参数1：filter 过滤器（为空则匹配所有）参数2：newObj 新对象，包含更新运算符（例如$set）或替换文档（即只有字段：值表达式）的文档。参数3：option [ multi: 如果为FALSE，则仅更新第一个匹配的文档，为TRUE更新所有匹配的文档。如果newObj是替换文档，则此选项不能为TRUE。 upsert：如果过滤器与现有文档不匹配，请插入单个文档。如果文档是替换文档（即没有更新操作符），则将从newObj创建该文档;否则，newObj中的运算符将应用于过滤以创建新文档 ] */ $bulk-&gt;update( [&#x27;age&#x27;=&gt;19, &#x27;hh&#x27;=&gt;2], [&#x27;$set&#x27; =&gt; [&#x27;name&#x27; =&gt; &#x27;菜鸟19号&#x27;]], [&#x27;multi&#x27; =&gt; true, &#x27;upsert&#x27; =&gt; true] ); $rs = $manager-&gt;executeBulkWrite(&#x27;xxj.runoob&#x27;, $bulk);// 删 $bulk-&gt;delete([&#x27;age&#x27;=&gt;19]); $rs = $manager-&gt;executeBulkWrite(&#x27;xxj.runoob&#x27;, $bulk);// 查 //$filter是删选条件 $filter = []; $query = new MongoDB\\Driver\\Query($filter); $rs = $manager-&gt;executeQuery(&#x27;xxj.runoob&#x27;, $query);","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"}],"tags":[]}],"categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"服务器/Linux","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Hexo/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"PHP","slug":"后端/PHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/"},{"name":"环境","slug":"后端/PHP/环境","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/%E7%8E%AF%E5%A2%83/"},{"name":"ThinkPHP","slug":"后端/PHP/ThinkPHP","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/ThinkPHP/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://example.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"Web","slug":"服务器/Web","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Web/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"},{"name":"Laravel","slug":"后端/PHP/Laravel","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/Laravel/"},{"name":"宝塔","slug":"服务器/Linux/宝塔","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/%E5%AE%9D%E5%A1%94/"},{"name":"图片","slug":"后端/PHP/图片","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/%E5%9B%BE%E7%89%87/"},{"name":"设计模式","slug":"后端/PHP/设计模式","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Vue","slug":"前端/JavaScript/Vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/Vue/"},{"name":"axios","slug":"前端/JavaScript/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/axios/"},{"name":"IDE","slug":"IDE","permalink":"http://example.com/categories/IDE/"},{"name":"IDEA","slug":"IDE/IDEA","permalink":"http://example.com/categories/IDE/IDEA/"},{"name":"Python","slug":"后端/Python","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Python/"},{"name":"Swoole","slug":"后端/PHP/Swoole","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/PHP/Swoole/"}],"tags":[]}